preciso fazer a coneção com o meu banco de dados para acessar o aplicativo mobile com a api:
esse é o meu controller: const Usuario = require("../Models/Class/Usuario")
const AccountManagementQueries = require("../Models/Query/AccountQueries")
const bcrypt = require('bcrypt');







const accountManagement = {
  cadastraUsuario: async (req, res) => {

    try {
      const { NomeUsuario, DataNasc, Email, Senha, Cep, Rua, Numero, Bairro, Estado, Cidade } = req.body

      if (NomeUsuario, DataNasc, Email, Senha, Cep, Rua, Numero, Bairro, Estado, Cidade) {
        if (typeof (Email) == 'number') {
          res.json({ error: "O Campo Email não pode ser numero" })
        } else if (typeof (NomeUsuario) !== 'string') {
          res.json({ error: "O Campo Nome não pode ser diferente de texto" })
        } else if (typeof (Senha) !== 'string') {
          res.json({ error: "O Campo Senha está com tipo diferente do esperado" })
        } else if (typeof (Cep) !== 'string') {
          res.json({ error: "O Campo CEP está com tipo diferente do esperado" })
        } else if (typeof (Rua) !== 'string') {
          res.json({ error: "O Campo Rua está com tipo diferente do esperado" })
        } else if (typeof (Numero) !== 'number') {
          res.json({ error: "O Campo Numero está com tipo diferente do esperado" })
        } else if (typeof (Bairro) !== 'string') {
          res.json({ error: "O Campo Bairro está com tipo diferente do esperado" })
        } else if (typeof (Estado) !== 'string') {
          res.json({ error: "O Campo Estado está com tipo diferente do esperado" })
        } else if (typeof (Cidade) !== 'string') {
          res.json({ error: "O Campo Cidade está com tipo diferente do esperado" })
        }

        const validaCadastroAnterior = await AccountManagementQueries.verificaExistenciaUsuarioQuery(Email)

        if (validaCadastroAnterior.error) {
          res.json(validaCadastroAnterior)
        } else {
          const hashedPassword = await bcrypt.hash(Senha, 10); // aki ocorre a criptografia da parte da qual queremos, e determinamos que seja 10 apos o campo que queremos criptografar para que 10 mil registros com a mesma senha tenha criptografias diferentes, ou seja se 30 pessoas tiverem a mesma senha as 30 terão criptografias diferentes.
          console.log("sucess")
          console.log(validaCadastroAnterior)
          const newUser = new Usuario(NomeUsuario, DataNasc, Email, hashedPassword, Cep, Rua, Numero, Bairro, Estado, Cidade)
          //verificar se o Email passado já não existe no nosso banco de dados.

          const sendingData = await AccountManagementQueries.cadastraUsuarioQuery(newUser)

          res.json(sendingData)
        }

      }else{
        res.json({error:"Não foi enviado todos campos necessários para fazer o cadastro"})
      }
    }

    catch (e) {
      res.json({ error: "houve um problema no tratamento de seus dados: " })
    }

  },
  autenticaUsuario: async(req,res) => {
    const {Email,Senha} = req.body;
  
    try {
      if(Email,Senha) {
        if(typeof(Email) === 'string' && typeof (Senha) === 'string') {
        const re = /\S+@\S+\.\S+/;
        const testRegex = re.test(Email);

        if(testRegex === true) {
          const verifyExistence = await AccountManagementQueries.autenticaUsuarioQuery (Email,Senha);
          res.json (verifyExistence)
        }else{
          res.json({error:"o valor inserido no campo Email, não corresponde a um Email valido",auth:false})
        }

        }else {
          res.json({error:"O Email e a senha estão sendo enviados com tipos de dados divergentes do necessário. Contate um Suporte para correção do problema", auth:false})
        }
      } else {
        res.json({error:"Não foram encaminhados Email e Senha",auth:false})
      }
      
    }
    catch (e) {
      res.json ({error:e, auth:false})
    }
    
  }
}


module.exports = accountManagement


e essa é minha query: 
const { connection } = require(`../../Config/db`);
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

const AccountManagementQueries = {
  async cadastraUsuarioQuery (dataUser) {
    const conn = await connection();
      try {
        console.log('chegou')                                                                                                                                                                                         
        const uRes = await conn.query("INSERT INTO `Usuario` (`Nome`, `CEP`, `Rua`, `Numero`, `Bairro`, `Estado`, `DataNasc`, `Email`, `Senha`, `Administrador`,`Cidade`) VALUES (?,?,?,?,?,?,?,?,?,?,?)",[dataUser.NomeUsuario,dataUser.Cep,dataUser.Rua,dataUser.Numero,dataUser.Bairro,dataUser.Estado,dataUser.DataNasc,dataUser.Email,dataUser.Senha,0,dataUser.Cidade]);
        return {sucess:"você conseguiu se cadastrar com sucesso!!"}
      }
      catch (e) {
        return {error:"houve um erro ao tentar completar o envio de dados: " & e }
      }
  },
  async verificaExistenciaUsuarioQuery (Email) {
    const conn = await connection();
    try{
      const existenceReturn = await conn.query("Select Email from Usuario Where Email = ?", [Email])

      if(existenceReturn[0].length > 0) {
        return {error:"Um usuário com esse Email já está registrado em nosso sistema, tente utilizar outro!"}
      }else {
        return {sucess:"Usuário apto a prosseguir com cadastro."}
      }
    }catch(e) {
      console.error(e)
    }
  },
  async autenticaUsuarioQuery (Email,Senha) {
    const conn = await connection();

    try {
      const authResponse = await conn.query("Select * from Usuario where Email = ?",[Email])
      if(authResponse[0].length > 0) {
        const authVerify = await bcrypt.compare(Senha,authResponse[0][0].Senha)
        if(authVerify === true) {
          
          const token = jwt.sign({ ID: authResponse[0][0].ID, Nome:authResponse[0][0].Nome,CEP:authResponse[0][0].CEP,Rua:authResponse[0][0].Rua,Numero:authResponse[0][0].Numero,Bairro:authResponse[0][0].Bairro,Estado:authResponse[0][0].Estado,DataNasc:authResponse[0][0].DataNasc,Email:authResponse[0][0].Email,Administrador:authResponse[0][0].Administrador,Cidade:authResponse[0][0].Cidade}, process.env.SECRET, {
            expiresIn: 1000 // tempo em que o token irá expirar em segundos
          });

          return ({sucess:"Usuário logado com sucesso",auth:true,token:token})
          
        } else {
          return ({error:"Email ou senha incorreta.",auth:false})
        }
   
      }
    }
    catch (e) {
      console.error(e)
    }
  }
}


module.exports = AccountManagementQueries


estou usando o metodo do token.

como que eu faço para chamar essa query para validar na tela do meu aplicativo mobile, essa é ela:
import React from "react";
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  StatusBar,
  ImageBackground,
  Image,
} from "react-native";
import { auth } from "../../Firebase/FirebaseConfig"; // Certifique-se de importar corretamente
import { signInWithEmailAndPassword } from "firebase/auth"; // Adicione esta linha para a função correta

export default class TelaLogin extends React.Component {
  static navigationOptions = {
    header: null,
  };
  state = {
    email: "",
    senha: "",
    errorMessage: null,
  };

  handleLogin = () => {
    const { email, senha } = this.state;

    // Utilize a função signInWithEmailAndPassword corretamente
    signInWithEmailAndPassword(auth, email, senha)
      .then(() => {
        this.props.navigation.navigate("Home");
      })
      .catch((error) => this.setState({ errorMessage: error.message }));
  };

  render() {
    return (
      <View style={styles.container}>
        <StatusBar barStyle="light-content"></StatusBar>
        <Image
          source={require("../../../assets/ImagenLogin.jpg")}
          style={{marginTop: -10, width: 460, height: 150 }}
        />

        <Text style={styles.greeting}>{`Bem-vindo ao\nPatinhas do Bem`}</Text>

        <View style={styles.errorMessage}>
          {this.state.errorMessage && (
            <Text style={styles.error}>{this.state.errorMessage}</Text>
          )}
        </View>

        <View style={styles.form}>
          <Text style={styles.inputTitle}>Endereço de E-mail</Text>
          <TextInput
            style={styles.input}
            autoCapitalize="none"
            onChangeText={(email) => this.setState({ email })}
            value={this.state.email}
          />
        </View>

        <View style={styles.form}>
          <Text style={styles.inputTitle}>Senha</Text>
          <TextInput
            style={styles.input}
            secureTextEntry
            autoCapitalize="none"
            onChangeText={(senha) => this.setState({ senha })}
            value={this.state.senha}
          />
        </View>

        <TouchableOpacity style={styles.button} onPress={this.handleLogin}>
          <Text style={{ color: "#fff", fontWeight: "500" }}>Entrar</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={{ alignSelf: "center", margin: 32 }}
          onPress={() => this.props.navigation.navigate("Register")}
        >
          <Text style={{ color: "#414959", fontSize: 13 }}>
            Não tem conta?{" "}
            <Text style={{ fontWeight: "500", color: "#3DAAD9" }}>
              Cadastre-se
            </Text>
          </Text>
        </TouchableOpacity>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  greeting: {
    marginTop: -2,
    fontSize: 28,
    fontWeight: "400",
    textAlign: "center",
  },
  errorMessage: {
    height: 72,
    alignItems: "center",
    justifyContent: "center",
    marginHorizontal: 30,
  },
  error: {
    color: "#E9446A",
    fontSize: 13,
    fontWeight: "600",
    textAlign: "center",
  },
  form: {
    marginBottom: 48,
    marginHorizontal: 30,
  },
  inputTitle: {
    color: "#8A8F9E",
    textTransform: "uppercase",
  },
  input: {
    borderBottomColor: "#8A8F9E",
    borderBottomWidth: 1,
    height: 40,
    fontSize: 15,
    color: "#161F3D",
  },
  button: {
    marginHorizontal: 30,
    backgroundColor: "#3DAAD9",
    borderRadius: 4,
    height: 52,
    alignItems: "center",
    justifyContent: "center",
  },
});
 
oq eu devo fazer para funcionar??