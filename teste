const Usuario = require("../Models/Class/Usuario")
const AccountManagementQueries = require("../Models/Query/AccountQueries")
const bcrypt = require('bcrypt');







const accountManagement = {
  cadastraUsuario: async (req, res) => {

    try {
      const { NomeUsuario, DataNasc, Email, Senha, Cep, Rua, Numero, Bairro, Estado, Cidade } = req.body

      if (NomeUsuario, DataNasc, Email, Senha, Cep, Rua, Numero, Bairro, Estado, Cidade) {
        if (typeof (Email) == 'number') {
          res.json({ error: "O Campo Email não pode ser numero" })
        } else if (typeof (NomeUsuario) !== 'string') {
          res.json({ error: "O Campo Nome não pode ser diferente de texto" })
        } else if (typeof (Senha) !== 'string') {
          res.json({ error: "O Campo Senha está com tipo diferente do esperado" })
        } else if (typeof (Cep) !== 'string') {
          res.json({ error: "O Campo CEP está com tipo diferente do esperado" })
        } else if (typeof (Rua) !== 'string') {
          res.json({ error: "O Campo Rua está com tipo diferente do esperado" })
        } else if (typeof (Numero) !== 'number') {
          res.json({ error: "O Campo Numero está com tipo diferente do esperado" })
        } else if (typeof (Bairro) !== 'string') {
          res.json({ error: "O Campo Bairro está com tipo diferente do esperado" })
        } else if (typeof (Estado) !== 'string') {
          res.json({ error: "O Campo Estado está com tipo diferente do esperado" })
        } else if (typeof (Cidade) !== 'string') {
          res.json({ error: "O Campo Cidade está com tipo diferente do esperado" })
        }

        const validaCadastroAnterior = await AccountManagementQueries.verificaExistenciaUsuarioQuery(Email)

        if (validaCadastroAnterior.error) {
          res.json(validaCadastroAnterior)
        } else {
          const hashedPassword = await bcrypt.hash(Senha, 10); // aki ocorre a criptografia da parte da qual queremos, e determinamos que seja 10 apos o campo que queremos criptografar para que 10 mil registros com a mesma senha tenha criptografias diferentes, ou seja se 30 pessoas tiverem a mesma senha as 30 terão criptografias diferentes.
          console.log("sucess")
          console.log(validaCadastroAnterior)
          const newUser = new Usuario(NomeUsuario, DataNasc, Email, hashedPassword, Cep, Rua, Numero, Bairro, Estado, Cidade)
          //verificar se o Email passado já não existe no nosso banco de dados.

          const sendingData = await AccountManagementQueries.cadastraUsuarioQuery(newUser)

          res.json(sendingData)
        }

      }else{
        res.json({error:"Não foi enviado todos campos necessários para fazer o cadastro"})
      }
    }

    catch (e) {
      res.json({ error: "houve um problema no tratamento de seus dados: " })
    }

  },
  autenticaUsuario: async(req,res) => {
    const {Email,Senha} = req.body;
  
    try {
      if(Email,Senha) {
        if(typeof(Email) === 'string' && typeof (Senha) === 'string') {
        const re = /\S+@\S+\.\S+/;
        const testRegex = re.test(Email);

        if(testRegex === true) {
          const verifyExistence = await AccountManagementQueries.autenticaUsuarioQuery (Email,Senha);
          res.json (verifyExistence)
        }else{
          res.json({error:"o valor inserido no campo Email, não corresponde a um Email valido",auth:false})
        }

        }else {
          res.json({error:"O Email e a senha estão sendo enviados com tipos de dados divergentes do necessário. Contate um Suporte para correção do problema", auth:false})
        }
      } else {
        res.json({error:"Não foram encaminhados Email e Senha",auth:false})
      }
      
    }
    catch (e) {
      res.json ({error:e, auth:false})
    }
    
  }
}

module.exports = accountManagement

essa é minha rota: require("dotenv-safe").config();
const jwt = require('jsonwebtoken');
const express = require('express');
const router = express.Router();
const accountManagement = require ('../Controllers/accountController');
const petManagement = require("../Controllers/petController")


function verificadorDoToken(req, res, next){
  const token = req.headers['authorization'];
  if (!token) return res.status(401).json({ auth: false, message: 'Não foi informado nenhum token.' });
  
  jwt.verify(token, process.env.SECRET, function(err, decoded) {
    if (err) return res.status(500).json({ auth: false, message: 'Falha ao tentar autenticar o token.' });
    
    // se tudo estiver ok, salva no request para uso posterior
    req.dataUser = {ID:decoded.ID,Nome:decoded.Nome, CEP:decoded.CEP,Rua: decoded.Rua,
      Numero: decoded.Numero,
      Bairro: decoded.Bairro,
      Estado: decoded.Estado,
      DataNasc: decoded.DataNasc,
      Email: decoded.Email,
      Administrador: decoded.Administrador,
      Cidade: decoded.Cidade};
    next();
  });
}


// rota para o usuário fazer um cadastro no site.
router.post("/Cadastro",accountManagement.cadastraUsuario)


//Rota para o usuário logar no site (será retornado um token ao mesmo)
 router.post('/Login' ,accountManagement.autenticaUsuario) 


//Rota para cadastrar os dados de um novo pet 
 router.post ("/CadastraPet",verificadorDoToken,petManagement.cadastraPet)


  //Rota para Editar informações de um pet já cadastrado.
 router.put("/EditaPetInfo", verificadorDoToken,petManagement.editaPetInfo);


 //remove um pet da adoção ou inativa (obs: todos registros com status 1 está para adoção, todos registros com status 0 é por que foram doados graças a rede e só inativamos o registro).
 router.delete ("/RetiraPetAdocao",verificadorDoToken,petManagement.removePetDaAdocao)



  //puxa todos animais de um usuário especifico.
  router.get("/PetsUser", verificadorDoToken, petManagement.petsDeUmUsuario)


  //puxa todos animais que estão para adoção no mesmo estado da pessoa.
  router.get("/PetsAdocao", verificadorDoToken, petManagement.petsParaAdocao)


  //Rota que pode-se demonstrar interesse em um pet
  router.post ("/DemonstrarInteressePet", verificadorDoToken, petManagement.demonstrarInteresseEmPet)


  //Rota para ver todos animais que eu demonstrei interesse
  router.get ("/InteressadosMeuPet", verificadorDoToken, petManagement.interessadosMeuPet)


  //Rota para ver os pets no qual eu demonstrei interesse
  router.get ("/MeusInteresses", verificadorDoToken, petManagement.meusInteresses)


  //Rota para tirar interesse em algum pet
  router.delete ("/RemoverInteressePet", verificadorDoToken, petManagement.removerInteressePet)

module.exports = router;

e essa é minha query:
const { connection } = require(`../../Config/db`);
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

const AccountManagementQueries = {
  async cadastraUsuarioQuery (dataUser) {
    const conn = await connection();
      try {
        console.log('chegou')                                                                                                                                                                                         
        const uRes = await conn.query("INSERT INTO `Usuario` (`Nome`, `CEP`, `Rua`, `Numero`, `Bairro`, `Estado`, `DataNasc`, `Email`, `Senha`, `Administrador`,`Cidade`) VALUES (?,?,?,?,?,?,?,?,?,?,?)",[dataUser.NomeUsuario,dataUser.Cep,dataUser.Rua,dataUser.Numero,dataUser.Bairro,dataUser.Estado,dataUser.DataNasc,dataUser.Email,dataUser.Senha,0,dataUser.Cidade]);
        return {sucess:"você conseguiu se cadastrar com sucesso!!"}
      }
      catch (e) {
        return {error:"houve um erro ao tentar completar o envio de dados: " & e }
      }
  },
  async verificaExistenciaUsuarioQuery (Email) {
    const conn = await connection();
    try{
      const existenceReturn = await conn.query("Select Email from Usuario Where Email = ?", [Email])

      if(existenceReturn[0].length > 0) {
        return {error:"Um usuário com esse Email já está registrado em nosso sistema, tente utilizar outro!"}
      }else {
        return {sucess:"Usuário apto a prosseguir com cadastro."}
      }
    }catch(e) {
      console.error(e)
    }
  },
  async autenticaUsuarioQuery (Email,Senha) {
    const conn = await connection();

    try {
      const authResponse = await conn.query("Select * from Usuario where Email = ?",[Email])
      if(authResponse[0].length > 0) {
        const authVerify = await bcrypt.compare(Senha,authResponse[0][0].Senha)
        if(authVerify === true) {
          
          const token = jwt.sign({ ID: authResponse[0][0].ID, Nome:authResponse[0][0].Nome,CEP:authResponse[0][0].CEP,Rua:authResponse[0][0].Rua,Numero:authResponse[0][0].Numero,Bairro:authResponse[0][0].Bairro,Estado:authResponse[0][0].Estado,DataNasc:authResponse[0][0].DataNasc,Email:authResponse[0][0].Email,Administrador:authResponse[0][0].Administrador,Cidade:authResponse[0][0].Cidade}, process.env.SECRET, {
            expiresIn: 1000 // tempo em que o token irá expirar em segundos
          });

          return ({sucess:"Usuário logado com sucesso",auth:true,token:token})
          
        } else {
          return ({error:"Email ou senha incorreta.",auth:false})
        }
   
      }
    }
    catch (e) {
      console.error(e)
    }
  }
}


module.exports = AccountManagementQueries


esse é o erro que esta dando quando eu mando o metodo para a API:
chegou
node:_http_outgoing:652
    throw new ERR_HTTP_HEADERS_SENT('set');
          ^

Error [ERR_HTTP_HEADERS_SENT]: Cannot set headers after they are sent to th



essse é o conteudo que eu estou mandando: 
import React, { Component } from "react";
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  StatusBar,
  Image,
  Alert,
  ScrollView,
} from "react-native";
import { Ionicons } from '@expo/vector-icons';
import * as Font from 'expo-font';
import DateTimePicker from '@react-native-community/datetimepicker';
import axios from 'axios'; // Importando axios
import api from '../../Service/tokenService';

class TelaRegistro extends Component {
  state = {
    nome: '',
    email: '',
    senha: '',
    confirmarSenha: '',
    cep: '',
    rua: '',
    numero: '',
    bairro: '',
    cidade: '', // Adicionando o campo cidade
    estado: '',
    dataNascimento: new Date(),
    showDatePicker: false,
    fontLoaded: false,
  };

  async componentDidMount() {
    await this.loadFonts();
  }

  loadFonts = async () => {
    await Font.loadAsync({
      'Kavoon': require('../../../assets/font/Kavoon-Regular.ttf'),
    });
    this.setState({ fontLoaded: true });
  };

  fetchAddressByCep = async (cep) => {
    try {
      const response = await axios.get(`https://viacep.com.br/ws/${cep}/json/`);
      const { logradouro, bairro, localidade, uf } = response.data; // Adicionando localidade (cidade)

      if (logradouro) {
        this.setState({
          rua: logradouro,
          bairro: bairro,
          cidade: localidade, // Definindo cidade
          estado: uf,
        });
      } else {
        Alert.alert("Erro", "CEP não encontrado.");
      }
    } catch (error) {
      Alert.alert("Erro", "Ocorreu um erro ao buscar o endereço: " + error.message);
    }
  };

  handleCepChange = (cep) => {
    this.setState({ cep });
    if (cep.length === 8) { // Valida se o CEP tem 8 dígitos
      this.fetchAddressByCep(cep);
    }
  };

  handleRegister = async () => {
    const { nome, email, senha, confirmarSenha, cep, rua, numero, bairro, cidade, estado, dataNascimento } = this.state;
  
    if (senha !== confirmarSenha) {
      Alert.alert("Erro", "As senhas não coincidem.");
      return;
    }
  
    if (!nome || !email || !senha || !cep || !rua || !numero || !bairro || !cidade || !estado) {
      Alert.alert("Erro", "Todos os campos são obrigatórios.");
      return;
    }
  
    const emailRegex = /\S+@\S+\.\S+/;
    if (!emailRegex.test(email)) {
      Alert.alert("Erro", "Insira um endereço de e-mail válido.");
      return;
    }
  
    const formattedDate = dataNascimento.toISOString().split('T')[0];
  
    try {
      const response = await api.post('/Cadastro', {
        NomeUsuario: nome,
        DataNasc: formattedDate,
        Email: email,
        Senha: senha,
        Cep: cep,
        Rua: rua,
        Numero: numero,
        Bairro: bairro,
        Cidade: cidade,
        Estado: estado,
      });
  
      if (response.data.success) {
        Alert.alert("Sucesso", "Usuário registrado com sucesso!");
        this.props.navigation.navigate("Login");
      } else {
        Alert.alert("Erro", response.data.message || "Ocorreu um erro ao registrar o usuário.");
      }
    } catch (error) {
      console.error(error);
      Alert.alert("Erro", "Ocorreu um erro ao registrar o usuário: " + error.message);
    }
  };
  

  showDatepicker = () => {
    this.setState({ showDatePicker: true });
  };

  onChange = (event, selectedDate) => {
    const currentDate = selectedDate || this.state.dataNascimento;
    this.setState({ showDatePicker: false, dataNascimento: currentDate });
  };

  renderInput(title, iconName, stateKey, keyboardType = "default", placeholder = "", secureTextEntry = false, editable = true) {
    return (
      <View style={styles.form}>
        <Text style={styles.inputTitle}>{title}</Text>
        <View style={styles.inputContainer}>
          <Ionicons name={iconName} size={20} color="#134973" />
          <TextInput
            style={styles.input}
            keyboardType={keyboardType}
            secureTextEntry={secureTextEntry}
            placeholder={placeholder}
            onChangeText={(value) => {
              // Atualiza o campo de CEP e busca o endereço
              if (stateKey === "cep") {
                this.handleCepChange(value);
              } else {
                this.setState({ [stateKey]: value });
              }
            }}
            value={this.state[stateKey]}
            editable={editable}
          />
        </View>
      </View>
    );
  }

  render() {
    const { showDatePicker, dataNascimento } = this.state;

    return (
      <View style={styles.container}>
        <StatusBar barStyle="light-content" />
        <Image
          source={require("../../../assets/image/ImagenLogin.jpg")}
          style={{ marginTop: -10, width: 460, height: 150 }}
        />
        {this.state.fontLoaded && (
          <Text style={styles.greeting}>{`Bem-vindo ao\nPatinhas do Bem`}</Text>
        )}

        <ScrollView contentContainerStyle={styles.scrollContainer}>
          {this.renderInput("Nome", "person-outline", "nome")}
          {this.renderInput("CEP", "pin", "cep", "numeric")}
          {this.renderInput("Rua", "home-outline", "rua", "default", "", false, false)}
          {this.renderInput("Número", "pin", "numero", "numeric")}
          {this.renderInput("Bairro", "home", "bairro", "default", "", false, false)}
          {this.renderInput("Cidade", "location-outline", "cidade", "default", "", false, false)}
          {this.renderInput("Estado", "flag", "estado", "default", "", false, false)}

          {/* Campo de Data de Nascimento */}
          <View style={styles.form}>
            <Text style={styles.inputTitle}>Data de Nascimento</Text>
            <TouchableOpacity onPress={this.showDatepicker} style={styles.inputContainer}>
              <Ionicons name="calendar-outline" size={20} color="#134973" />
              <Text style={styles.input}>
                {dataNascimento.toLocaleDateString()}
              </Text>
            </TouchableOpacity>
            {showDatePicker && (
              <DateTimePicker
                value={dataNascimento}
                mode="date"
                display="spinner"
                onChange={this.onChange}
                style={{ width: '100%' }}
              />
            )}
          </View>

          {this.renderInput("Endereço de E-mail", "mail-outline", "email", "none")}
          {this.renderInput("Senha", "lock-closed-outline", "senha", "none", null, true)}
          {this.renderInput("Confirmar Senha", "lock-closed-outline", "confirmarSenha", "none", null, true)}

          <TouchableOpacity style={styles.button} onPress={this.handleRegister}>
            <Text style={{ color: "#fff", fontWeight: "500" }}>Cadastrar</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={{ alignSelf: "center", margin: 32 }}
            onPress={() => this.props.navigation.navigate("Login")}
          >
            <Text style={{ color: "#414959", fontSize: 13 }}>
              Já tem conta?{" "}
              <Text style={{ fontWeight: "500", color: "#134973" }}>
                Faça login
              </Text>
            </Text>
          </TouchableOpacity>
        </ScrollView>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollContainer: {
    paddingBottom: 30,
  },
  greeting: {
    marginTop: -2,
    fontSize: 28,
    fontWeight: "400",
    textAlign: "center",
    color: "#000",
    fontFamily: 'Kavoon',
  },
  form: {
    marginBottom: 48,
    marginHorizontal: 30,
  },
  inputTitle: {
    color: "#8A8F9E",
    textTransform: "uppercase",
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderBottomColor: "#134973",
    borderBottomWidth: 1,
    height: 40,
  },
  input: {
    flex: 1,
    marginLeft: 10,
    fontSize: 15,
    color: "#134973",
  },
  button: {
    marginHorizontal: 30,
    backgroundColor: "#134973",
    borderRadius: 5,
    height: 50,
    alignItems: "center",
    justifyContent: "center",
  },
});

export default TelaRegistro;
